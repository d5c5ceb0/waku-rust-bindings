// std
// crates
use serde::{Deserialize, Serialize};
// internal

pub type PubsubTopic = String;
pub type ContentTopic = String;
pub type WakuMessageVersion = usize;

/// JsonResponse wrapper.
/// `go-waku` ffi returns this type as a `char *` as per the [specification](https://rfc.vac.dev/spec/36/#jsonresponse-type)
/// This is internal, as it is better to use rust plain `Result` type.
#[derive(Deserialize)]
#[serde(rename_all = "snake_case")]
pub(crate) enum JsonResponse<T> {
    Result(T),
    Error(String),
}

/// Waku response, just a `Result` with an `String` error.
/// Convenient we can transform a [`JsonResponse`] into a [`std::result::Result`]
pub type Result<T> = std::result::Result<T, String>;

impl<T> From<JsonResponse<T>> for Result<T> {
    fn from(response: JsonResponse<T>) -> Self {
        match response {
            JsonResponse::Result(t) => Ok(t),
            JsonResponse::Error(e) => Err(e),
        }
    }
}

/// JsonMessage, Waku message in JSON format.
/// as per the [specification](https://rfc.vac.dev/spec/36/#jsonmessage-type)
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct WakuMessage {
    payload: Box<[u8]>,
    /// The content topic to be set on the message
    content_topic: ContentTopic,
    /// The Waku Message version number
    version: WakuMessageVersion,
    /// Unix timestamp in nanoseconds
    timestamp: usize,
}

/// A payload once decoded, used when a received Waku Message is encrypted
pub struct DecodedPayload {
    /// Public key that signed the message (optional), hex encoded with 0x prefix
    public_key: Option<String>,
    /// Message signature (optional), hex encoded with 0x prefix
    signature: Option<String>,
    /// Decrypted message payload base64 encoded
    data: String,
    /// Padding base64 encoded
    padding: String,
}

/// The content topic of a Waku message
/// as per the [specification](https://rfc.vac.dev/spec/36/#contentfilter-type)
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ContentFilter {
    /// The content topic of a Waku message
    content_topic: ContentTopic,
}

/// The criteria to create subscription to a light node in JSON Format
/// as per the [specification](https://rfc.vac.dev/spec/36/#filtersubscription-type)
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FilterSubscription {
    /// Array of [`ContentFilter`] being subscribed to / unsubscribed from
    content_filters: Vec<ContentFilter>,
    /// Optional pubsub topic
    pubsub_topic: Option<PubsubTopic>,
}

/// Criteria used to retrieve historical messages
#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub struct StoreQuery {
    /// The pubsub topic on which messages are published
    pubsub_topic: Option<PubsubTopic>,
    /// Array of [`ContentFilter`] to query for historical messages
    content_filters: Vec<ContentFilter>,
    /// The inclusive lower bound on the timestamp of queried messages.
    /// This field holds the Unix epoch time in nanoseconds
    start_time: Option<usize>,
    /// The inclusive upper bound on the timestamp of queried messages.
    /// This field holds the Unix epoch time in nanoseconds
    end_time: Option<usize>,
    /// Paging information in [`PagingOptions`] format
    paging_options: Option<PagingOptions>,
}

/// The response received after doing a query to a store node
#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct StoreResponse {
    /// Array of retrieved historical messages in [`WakuMessage`] format
    messages: Vec<WakuMessage>,
    /// Paging information in [`PagingOptions`] format from which to resume further historical queries
    paging_options: Option<PagingOptions>,
}

/// Paging information
#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PagingOptions {
    /// Number of messages to retrieve per page
    page_size: usize,
    /// Message Index from which to perform pagination.
    /// If not included and forward is set to `true`, paging will be performed from the beginning of the list.
    /// If not included and forward is set to `false`, paging will be performed from the end of the list
    cursor: Option<MessageIndex>,
    /// `true` if paging forward, `false` if paging backward
    forward: bool,
}

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MessageIndex {
    /// Hash of the message at this [`MessageIndex`]
    digest: String,
    /// UNIX timestamp in nanoseconds at which the message at this [`MessageIndex`] was received
    receiver_time: usize,
    /// UNIX timestamp in nanoseconds at which the message is generated by its sender
    sender_time: usize,
    /// The pubsub topic of the message at this [`MessageIndex`]
    pubsub_topic: PubsubTopic,
}
